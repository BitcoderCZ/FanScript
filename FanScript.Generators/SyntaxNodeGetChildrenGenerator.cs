using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;

namespace FanScript.Generators;

[Generator]
public class SyntaxNodeGetChildrenGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(static postInitializationContext =>
		{
			postInitializationContext.AddSource("GeneratedGetChildrenAttribute.g.cs", SourceText.From("""
                using System;
                using Microsoft.CodeAnalysis;

                namespace FanScript.Compiler.Syntax
                {
                    [AttributeUsage(AttributeTargets.Class)]
                    internal sealed class GeneratedGetChildrenAttribute : Attribute
                    {
                    }
                }
                """, Encoding.UTF8));
		});

		var pipeline = context.SyntaxProvider.ForAttributeWithMetadataName(
		   fullyQualifiedMetadataName: "FanScript.Compiler.Syntax.GeneratedGetChildrenAttribute",
		   predicate: static (syntaxNode, cancellationToken) => true,
		   transform: static (context, cancellationToken) =>
		   {
			   var @class = (INamedTypeSymbol)context.TargetSymbol;
			   var properties = @class.GetMembers().OfType<IPropertySymbol>().Select(prop => new Property(prop.Name, prop.Type.ToDisplayString(), prop.Type.NullableAnnotation == NullableAnnotation.Annotated, IsDerivedFrom(prop.Type, "SyntaxNode")));
			   return new Model(
				   ClassName: @class.Name,
				   Properties: properties.ToImmutableArray());
		   }
		);

		context.RegisterSourceOutput(pipeline, static (context, model) =>
		{
			string indentString = "    ";
			using (var stringWriter = new StringWriter())
			using (var indentedTextWriter = new IndentedTextWriter(stringWriter, indentString))
			{
				indentedTextWriter.WriteLine("// <auto-generated/>");
				indentedTextWriter.WriteLine("using System;");
				indentedTextWriter.WriteLine("using System.Collections.Generic;");
				indentedTextWriter.WriteLine("using System.Collections.Immutable;");
				indentedTextWriter.WriteLine();

				using (indentedTextWriter.CurlyIndent("namespace FanScript.Compiler.Syntax"))
				using (indentedTextWriter.CurlyIndent($"partial class {model.ClassName}"))
				using (indentedTextWriter.CurlyIndent("public override IEnumerable<SyntaxNode> GetChildren()"))
				{
					foreach (var property in model.Properties)
					{
						if (property.Type == "FanScript.Compiler.Syntax.ModifierClauseSyntax")
						{
							indentedTextWriter.WriteLine($"foreach (var child in {property.Name}.Modifiers)");
							indentedTextWriter.WriteLine($"{indentString}yield return child;");
						}
						else if (property.IsSyntaxNode)
						{
							if (property.Nullable)
							{
								indentedTextWriter.WriteLine($"if ({property.Name} is not null)");
								indentedTextWriter.Indent++;
							}

							indentedTextWriter.WriteLine($"yield return {property.Name};");

							if (property.Nullable)
							{
								indentedTextWriter.Indent--;
							}
						}
						else if (property.Type.StartsWith("System.Collections.Immutable.ImmutableArray"))
						{
							indentedTextWriter.WriteLine($"foreach (var child in {property.Name})");
							indentedTextWriter.WriteLine($"{indentString}yield return child;");
						}
						else if (property.Type.StartsWith("IsSeperatedSyntaxList", StringComparison.Ordinal))
						{
							indentedTextWriter.WriteLine($"foreach (var child in {property.Name}.GetWithSeparators())");
							indentedTextWriter.WriteLine($"{indentString}yield return child;");
						}
					}
				}

				indentedTextWriter.Flush();
				stringWriter.Flush();

				context.AddSource($"{model.ClassName}_GetChildren.g.cs", SourceText.From(stringWriter.ToString(), Encoding.UTF8));
			}
		});
	}

	private static bool IsDerivedFrom(ITypeSymbol typeSymbol, string baseTypeName)
	{
		var currentBaseType = typeSymbol.BaseType;

		while (currentBaseType != null)
		{
			if (currentBaseType.Name == baseTypeName)
			{
				return true;
			}

			currentBaseType = currentBaseType.BaseType;
		}

		return false;
	}

	private record Model(string ClassName, ImmutableArray<Property> Properties);

	private record struct Property(string Name, string Type, bool Nullable, bool IsSyntaxNode);
}